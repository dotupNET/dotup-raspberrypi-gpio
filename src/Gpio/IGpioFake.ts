import { Gpio } from "pigpio";

/*
 * File generated by Interface generator (dotup.dotup-vscode-interface-generator)
 * Date: 2020-03-08 07:30:48 
*/

interface IGpioFakeConstructor {
  new(
    gpio: number,
    options?: {
      /**
       * INPUT, OUTPUT, ALT0, ALT1, ALT2, ALT3, ALT4, or ALT5 (optional, no default)
       */
      mode?: number;

      /**
       * PUD_OFF, PUD_DOWN, or PUD_UP (optional, no default)
       */
      pullUpDown?: number;

      /**
       * interrupt edge for inputs. RISING_EDGE, FALLING_EDGE, or EITHER_EDGE (optional, no default)
       */
      edge?: number;

      /**
       * interrupt timeout in milliseconds (optional, defaults to 0 meaning no timeout if edge specified)
       */
      timeout?: number;

      /**
       * boolean specifying whether or not alert events are emitted when the GPIO changes state (optional, default false)
       */
      alert?: boolean;
    }
  ): Ab; //IGpioFake | Gpio;
}
/**
 * *********************************
 * Gpio
 * **********************************
 */
/**
 * General Purpose Input Output
 */
interface IGpioFake {

  /**
   * Sets the GPIO mode.
   * @param mode  INPUT, OUTPUT, ALT0, ALT1, ALT2, ALT3, ALT4, or ALT5
   */
  mode(mode: number): IGpioFake;
  /**
   * Sets or clears the resistor pull type for the GPIO.
   * @param pud   PUD_OFF, PUD_DOWN, or PUD_UP
   */
  pullUpDown(pud: number): IGpioFake;
  /**
   * Returns the GPIO mode.
   */
  getMode(): number;
  /**
   * Returns the GPIO level, 0 or 1.
   */
  digitalRead(): number;
  /**
   * Sets the GPIO level to 0 or 1. If PWM or servo pulses are active on the GPIO they are switched off.
   * @param level     0 or 1
   */
  digitalWrite(level: number): IGpioFake;
  /**
   * Sends a trigger pulse to the GPIO. The GPIO is set to level for pulseLen microseconds and then reset to not level.
   * @param pulseLen  pulse length in microseconds (1 - 100)
   * @param level     0 or 1
   */
  trigger(pulseLen: number, level: number): IGpioFake;
  /**
   * Starts PWM on the GPIO. Returns this.
   * @param dutyCycle     an unsigned integer >= 0 (off) and <= range (fully on). range defaults to 255.
   */
  pwmWrite(dutyCycle: number): IGpioFake;
  /**
   * The same to #pwmWrite.
   * @param dutyCycle     an unsigned integer >= 0 (off) and <= range (fully on). range defaults to 255.
   */
  analogWrite(dutyCycle: number): IGpioFake;
  /**
   * Starts hardware PWM on the GPIO at the specified frequency and dutyCycle. Frequencies above 30MHz are unlikely to work.
   * @param frequency     an unsigned integer >= 0 and <= 125000000
   * @param dutyCycle     an unsigned integer >= 0 (off) and <= 1000000 (fully on).
   */
  hardwarePwmWrite(frequency: number, dutyCycle: number): IGpioFake;
  /**
   * Returns the PWM duty cycle setting on the GPIO.
   */
  getPwmDutyCycle(): number;
  /**
   * Selects the duty cycle range to be used for the GPIO. Subsequent calls to pwmWrite will use a duty cycle between 0 (off) and range (fully on).
   * @param range     an unsigned integer in the range 25 through 40000
   */
  pwmRange(range: number): IGpioFake;
  /**
   * Returns the duty cycle range used for the GPIO.
   * If hardware PWM is active on the GPIO the reported range will be 1000000.
   */
  getPwmRange(): number;
  /**
   * Returns the real range used for the GPIO.
   * If hardware PWM is active on the GPIO the reported real range will be approximately 250M divided by the set PWM frequency.
   */
  getPwmRealRange(): number;
  /**
   * Sets the frequency in hertz to be used for the GPIO. Returns this.
   * @param frequency      an unsigned integer >= 0
   */
  pwmFrequency(frequency: number): IGpioFake;
  /**
   * Returns the frequency (in hertz) used for the GPIO. The default frequency is 800Hz.
   */
  getPwmFrequency(): number;
  /**
   * Starts servo pulses at 50Hz on the GPIO, 0 (off), 500 (most anti-clockwise) to 2500 (most clockwise)
   * @param pulseWidth    pulse width in microseconds, an unsigned integer, 0 or a number in the range 500 through 2500
   */
  servoWrite(pulseWidth: number): IGpioFake;
  /**
   * Returns the servo pulse width setting on the GPIO.
   */
  getServoPulseWidth(): number;
  /**
   * Enables interrupts for the GPI
   * @param edge      RISING_EDGE, FALLING_EDGE, or EITHER_EDGE
   * @param timeout   interrupt timeout in milliseconds (optional, defaults to 0 meaning no timeout)
   */
  enableInterrupt(edge: number, timeout?: number): IGpioFake;
  /**
   * Disables interrupts for the GPIO. Returns this.
   */
  disableInterrupt(): IGpioFake;
  /**
   * Enables alerts for the GPIO. Returns this.
   */
  enableAlert(): IGpioFake;
  /**
   * Disables aterts for the GPIO. Returns this.
   */
  disableAlert(): IGpioFake;
  /**
   * Sets a glitch filter on a GPIO. Returns this.
   * @param steady    Time, in microseconds, during which the level must be stable. Maximum value: 300000
   */
  glitchFilter(steady: number): IGpioFake;
}

/**
 * *********************************
 * GpioBank
 * ***********************************
 * 
 * *
 * Banked General Purpose Input Output
 */
export interface IGpioBank {
  /**
   * Returns the current level of all GPIOs in the bank.
   */
  read(): number;
  /**
   * For each GPIO in the bank, sets the GPIO level to 1 if the corresponding bit in bits is set.
   * @param bits  a bit mask of the the GPIOs to set to 1
   */
  set(bits: number): IGpioBank;
  /**
   * For each GPIO in the bank, sets the GPIO level to 0 if the corresponding bit in bits is set.
   * @param bits   a bit mask of the the GPIOs to clear or set to 0
   */
  clear(bits: number): IGpioBank;
  /**
   * Returns the bank identifier (BANK1 or BANK2.)
   */
  bank(): number;
}

/**
 * *********************************
 * Notifier
 * ***********************************
 * 
 * *
 * Notification Stream
 */
export interface INotifier {
  /**
   * Starts notifications for the GPIOs specified in the bit mask.
   * @param bits  a bit mask indicating the GPIOs of interest, bit0 corresponds to GPIO0, bit1 corresponds to GPIO1, ..., bit31 corresponds to GPIO31.
   * If a bit is set, the corresponding GPIO will be monitored for state changes.
   */
  start(bits: number): INotifier;
  /**
   * Stops notifications. Notifications can be restarted with the start method.
   */
  stop(): INotifier;
  /**
   * Stops notifications and releases resources.
   */
  close(): INotifier;
  /**
   * Returns the notification stream which is a Readable stream.
   */
  stream(): any;
}

export interface Ab extends IGpioFake, IGpioFakeConstructor {

}